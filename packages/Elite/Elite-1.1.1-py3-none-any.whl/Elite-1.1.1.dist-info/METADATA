Metadata-Version: 2.1
Name: Elite
Version: 1.1.1
Summary: A lightweight module for elliptic-curve security schemes.
Home-page: https://github.com/origamizyt/Elite
Author: origamizyt
Author-email: zhaoyitong18@163.com
License: UNKNOWN
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3
Description-Content-Type: text/markdown
Requires-Dist: ecdsa
Requires-Dist: PyCryptodome

# Elite v1.1.1

A lightweight module for elliptic-curve security schemes.

*Repository: https://github.com/origamizyt/Elite*

---

## 1. Installation

This module is available on PyPI, which you can install by running the command below:
```
pip install Elite
```

The source code is also available on Github.

## 2. Usage

### 2.1 Concepts

There are a few concepts you need to know before coping with this module. Otherwise you may get lost in the usage and description. You'll need to you what is a:

- **Scheme**. A security scheme is an object which encapsulates the standard procedures in its methods and provides simple interfaces to operate with.
- **Cryptography Provider**. A crypto provider is an instance which manages the symmetric algorithm part of the scheme.

### 2.2 Basic usage

For top-level functionalities, you can instantiate an instance of a scheme either by calling `getscheme` or directly create an instance. However, it's recommended that beginners use the `getscheme` method:
```py
import elite
# server side
s = elite.getscheme()
# client side
c = elite.getscheme()
```

After instantiating a scheme, you can export your local public key or import remote key by calling the following methods:
```py
# binary version
c.importBinaryKey(s.exportBinaryKey())
# hex version
s.importHexKey(c.exportHexKey())
```

After loading the keys, a shared secret should now be established. Call the `secret` method to generate a shared secret. The two secrets should be the same.
```py
# should be the same
print(s.secret())
print(c.secret())
```

Sign / Verify data via the `sign` / `verify` method:
```py
signature = s.sign(b'data')
assert c.verify(b'data', signature)
```

Encrypt / Decrypt data via the `encrypt` / `decrypt` method:
```py
data = s.encrypt(b'data')
assert b'data' == c.decrypt(data)
```

> *NOTE*: a scheme can only verify / decrypt data from the other side. Don't try to verify / decrypt data generated by yourself.

### 2.3 Advanced usage

For mid-level programmers, you could try instantiating the schemes directly. They are in the `scheme` submodule.
```py
from elite.scheme import P384r1AesGcmScheme
# secp384r1 with AES_GCM
s = P384r1AesGcmScheme()
c = P384r1AesGcmScheme()
```

For high-level programmers, you can instantiate the `ECCScheme` class to create your own schemes:
```py
from elite.scheme import ECCScheme
from elite.cipher import getprovider
from elite.secret import CurveKind

s = ECCScheme(CurveKind.CK_SECP256K1, getprovider())
```

You can test the module using unittest:
```
$ python -m unittest elite.test --verbose
```

For deeper usage, please view the source code.


