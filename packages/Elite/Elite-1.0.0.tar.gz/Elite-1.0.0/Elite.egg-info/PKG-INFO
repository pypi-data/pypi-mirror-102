Metadata-Version: 2.1
Name: Elite
Version: 1.0.0
Summary: A lightweight module for elliptic-curve security schemes.
Home-page: https://github.com/origamizyt/Elite
Author: origamizyt
Author-email: zhaoyitong18@163.com
License: UNKNOWN
Description: # Elite v1.0.0
        
        A lightweight module for elliptic-curve security schemes.
        
        *Repository: https://github.com/origamizyt/Elite*
        
        ---
        
        ## 1. Installation
        
        This module is available on PyPI, which you can install by running the command below:
        ```
        pip install Elite
        ```
        
        The source code is also available on Github.
        
        ## 2. Usage
        
        ### 2.1 Concepts
        
        There are a few concepts you need to know before coping with this module. Otherwise you may get lost in the usage and description. You'll need to you what is a:
        
        - **Scheme**. A security scheme is an object which encapsulates the standard procedures in its methods and provides simple interfaces to operate with.
        - **Cryptography Provider**. A crypto provider is an instance which manages the symmetric algorithm part of the scheme.
        
        ### 2.2 Basic usage
        
        For top-level functionalities, you can instantiate an instance of a scheme either by calling `getscheme` or directly create an instance. However, it's recommended that beginners use the `getscheme` method:
        ```py
        import elite
        # server side
        s = elite.getscheme()
        # client side
        c = elite.getscheme()
        ```
        
        After instantiating a scheme, you can export your local public key or import remote key by calling the following methods:
        ```py
        # binary version
        c.importBinaryKey(s.exportBinaryKey())
        # hex version
        s.importHexKey(c.exportHexKey())
        ```
        
        After loading the keys, a shared secret should now be established. Call the `secret` method to generate a shared secret. The two secrets should be the same.
        ```py
        # should be the same
        print(s.secret())
        print(c.secret())
        ```
        
        Sign / Verify data via the `sign` / `verify` method:
        ```py
        signature = s.sign(b'data')
        assert c.verify(b'data', signature)
        ```
        
        Encrypt / Decrypt data via the `encrypt` / `decrypt` method:
        ```py
        data = s.encrypt(b'data')
        assert b'data' == c.decrypt(data)
        ```
        
        > *NOTE*: a scheme can only verify / decrypt data from the other side. Don't try to verify / decrypt data generated by yourself.
        
        ### 2.3 Advanced usage
        
        For mid-level programmers, you could try instantiating the schemes directly. They are in the `scheme` submodule.
        ```py
        from elite.scheme import P384r1AesGcmScheme
        # secp384r1 with AES_GCM
        s = P384r1AesGcmScheme()
        c = P384r1AesGcmScheme()
        ```
        
        For high-level programmers, you can instantiate the `ECCScheme` class to create your own schemes:
        ```py
        from elite.scheme import ECCScheme
        from elite.cipher import getprovider
        from elite.secret import CurveKind
        
        s = ECCScheme(CurveKind.CK_SECP256K1, getprovider())
        ```
        
        For deeper usage, please view the source code.
        
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3
Description-Content-Type: text/markdown
