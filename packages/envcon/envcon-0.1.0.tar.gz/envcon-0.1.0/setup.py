# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['envcon', 'envcon.utils']

package_data = \
{'': ['*']}

install_requires = \
['python-dotenv>=0.17.0,<0.18.0']

setup_kwargs = {
    'name': 'envcon',
    'version': '0.1.0',
    'description': '',
    'long_description': '# environs: simplified environment variable parsing\n\n\n**envcon**. easy environment variables parsing.\nenvcon allows you to store configuration separated from your code, like \n[The Twelve-Factor App](https://12factor.net/config) suggests.\n\n## Contents\n\n- [Features](#features)\n- [Install](#install)\n- [Basic usage](#basic-usage)\n- [Supported types](#supported-types)\n- [Reading .env files](#reading-env-files)\n  - [Reading a specific file](#reading-a-specific-file)\n- [Handling prefixes](#handling-prefixes)\n- [Variable expansion](#variable-expansion)\n- [Validation](#validation)\n- [Deferred validation](#deferred-validation)\n- [Serialization](#serialization)\n- [Defining custom parser behavior](#defining-custom-parser-behavior)\n- [Usage with Flask](#usage-with-flask)\n- [Usage with Django](#usage-with-django)\n- [Why...?](#why)\n  - [Why envvars?](#why-envvars)\n  - [Why not os.environ?](#why-not-osenviron)\n  - [Why another library?](#why-another-library)\n- [License](#license)\n\n## Features\n\n- Type-casting\n- Parse `.env` files as well as environment variables (`os.environ`) (useful for development)\n- Validation\n- Default values\n\n## Install\n\n    pip install envcon\n\n## Basic usage\n\nAssuming these environment variables are set (or written in .env file)\n\n```bash\nexport MONGO_USER=myMongoUser\nexport MONGO_PASSWORD=shh_its_a_secret\nexport SECRET_NUMBER=0.42\nexport ONE_TO_TEN=1,2,3,4,5,6,7,8,9,10\nexport IS_ENABLED=true\nexport URL=http://www.google.com\n```\n\nParse them with environs...\n\n```python3\nfrom envcon import environment_configuration\n\n@environment_configuration\nclass Configs:\n    SECRET_NUMBER: float\n    IS_ENABLED: bool\n    ONE_TO_TEN: list[int] # in python 3.8 use List[int] (from typing import List) \n\nprint(Configs.SECRET_NUMBER) # 0,42\nprint(type(Configs.SECRET_NUMBER)) # <class \'float\'>\nprint(Configs.IS_ENABLED) # True\nprint(type(Configs.IS_ENABLED)) # <class \'bool\'>\nprint(type(Configs.ONE_TO_TEN[0])) # <class \'int\'> \n\n@environment_configuration(prefix="MONGO_")\nclass MongoConfiguration:\n    USER: str\n    PASSWORD: str\n\nprint(MongoConfiguration.USER) # myMongoUser\n    \n```\n\n## Supported types\n\nThe following types are supported in type-hinting\n\nBuiltins:\n- `str`\n- `bool`\n- `int`\n- `float`\n- `list`\n- `dict` \n\nFrom `typing`\n\n## Reading `.env` files\n\n```bash\n# .env\nDEBUG=true\nPORT=4567\n```\n\nCall `Env.read_env` before parsing variables.\n\n```python\nfrom environs import Env\n\nenv = Env()\n# Read .env into os.environ\nenv.read_env()\n\nenv.bool("DEBUG")  # => True\nenv.int("PORT")  # => 4567\n```\n\n### Reading a specific file\n\nBy default, `Env.read_env` will look for a `.env` file in current\ndirectory and (if no .env exists in the CWD) recurse\nupwards until a `.env` file is found.\n\nYou can also read a specific file:\n\n```python\nfrom environs import Env\n\nwith open(".env.test", "w") as fobj:\n    fobj.write("A=foo\\n")\n    fobj.write("B=123\\n")\n\nenv = Env()\nenv.read_env(".env.test", recurse=False)\n\nassert env("A") == "foo"\nassert env.int("B") == 123\n```\n\n## Handling prefixes\n\n```python\n# export MYAPP_HOST=lolcathost\n# export MYAPP_PORT=3000\n\nwith env.prefixed("MYAPP_"):\n    host = env("HOST", "localhost")  # => \'lolcathost\'\n    port = env.int("PORT", 5000)  # => 3000\n\n# nested prefixes are also supported:\n\n# export MYAPP_DB_HOST=lolcathost\n# export MYAPP_DB_PORT=10101\n\nwith env.prefixed("MYAPP_"):\n    with env.prefixed("DB_"):\n        db_host = env("HOST", "lolcathost")\n        db_port = env.int("PORT", 10101)\n```\n\n## Variable expansion\n\n```python\n# export CONNECTION_URL=https://${USER:-sloria}:${PASSWORD}@${HOST:-localhost}/\n# export PASSWORD=secret\n# export YEAR=${CURRENT_YEAR:-2020}\n\nfrom environs import Env\n\nenv = Env(expand_vars=True)\n\nconnection_url = env("CONNECTION_URL")  # =>\'https://sloria:secret@localhost\'\nyear = env.int("YEAR")  # =>2020\n```\n\n\n## Deferred validation\n\nBy default, a validation error is raised immediately upon calling a parser method for an invalid environment variable.\nTo defer validation and raise an exception with the combined error messages for all invalid variables, pass `eager=False` to `Env`.\nCall `env.seal()` after all variables have been parsed.\n\n```python\n# export TTL=-2\n# export NODE_ENV=\'invalid\'\n# export EMAIL=\'^_^\'\n\nfrom environs import Env\nfrom marshmallow.validate import OneOf, Email, Length, Range\n\nenv = Env(eager=False)\n\nTTL = env.int("TTL", validate=Range(min=0, max=100))\nNODE_ENV = env.str(\n    "NODE_ENV",\n    validate=OneOf(\n        ["production", "development"], error="NODE_ENV must be one of: {choices}"\n    ),\n)\nEMAIL = env.str("EMAIL", validate=[Length(min=4), Email()])\n\nenv.seal()\n# environs.EnvValidationError: Environment variables invalid: {\'TTL\': [\'Must be greater than or equal to 0 and less than or equal to 100.\'], \'NODE_ENV\': [\'NODE_ENV must be one of: production, development\'], \'EMAIL\': [\'Shorter than minimum length 4.\', \'Not a valid email address.\']}\n```\n\n`env.seal()` validates all parsed variables and prevents further parsing (calling a parser method will raise an error).\n\n\n## Usage with Flask\n\n```python\n# myapp/settings.py\n\nfrom environs import Env\n\nenv = Env()\nenv.read_env()\n\n# Override in .env for local development\nDEBUG = env.bool("FLASK_DEBUG", default=False)\n# SECRET_KEY is required\nSECRET_KEY = env.str("SECRET_KEY")\n```\n\nLoad the configuration after you initialize your app.\n\n```python\n# myapp/app.py\n\nfrom flask import Flask\n\napp = Flask(__name__)\napp.config.from_object("myapp.settings")\n```\n\nFor local development, use a `.env` file to override the default\nconfiguration.\n\n```bash\n# .env\nDEBUG=true\nSECRET_KEY="not so secret"\n```\n\nNote: Because environs depends on [python-dotenv](https://github.com/theskumar/python-dotenv),\nthe `flask` CLI will automatically read .env and .flaskenv files.\n\n\n## Why...?\n\n### Why envvars?\n\nSee [The 12-factor App](http://12factor.net/config) section on\n[configuration](http://12factor.net/config).\n\n### Why not `os.environ`?\n\nWhile `os.environ` is enough for simple use cases, a typical application\nwill need a way to manipulate and validate raw environment variables.\nenvirons abstracts common tasks for handling environment variables.\n\nenvirons will help you\n\n- cast envvars to the correct type\n- specify required envvars\n- define default values\n- validate envvars\n- parse list and dict values\n- parse dates, datetimes, and timedeltas\n- parse expanded variables\n- serialize your configuration to JSON, YAML, etc.\n\n### Why use envcon?\n\n\n## License\n\nMIT licensed. ',
    'author': 'Neria',
    'author_email': 'me@neria.dev',
    'maintainer': 'Neria',
    'maintainer_email': 'me@neria.dev',
    'url': 'https://github.com/neriat/envcon',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
