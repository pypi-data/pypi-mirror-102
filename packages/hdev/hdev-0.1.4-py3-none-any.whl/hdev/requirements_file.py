"""hdev requirements implementation."""
import os
import re
from pathlib import Path

from pkg_resources import resource_filename

from hdev.tox_cmd import list_tox_environments, run_tox

DEFAULT_REQUIREMENTS_ORDER = [
    "requirements/requirements.in",
    "requirements/format.in",
    "requirements/dockercompose.in",
    "requirements/ssl.in",
    "requirements/build.in",
    "requirements/updatepdfjs.in",
    "requirements/dev.in",
    "requirements/tests.in",
    "requirements/functests.in",
    "requirements/bddtests.in",
    "requirements/lint.in",
]


PIP_TOOLS_REQUIREMENTS_PATH = resource_filename("hdev", "requirements/pip-tools.txt")


def _reformat_requirements(requirements_contents: str) -> str:
    multi_dep_re = re.compile(r".* # via .*,.*$")
    comment_re = re.compile(r"^#")

    def _remove_trailing(string):
        return re.sub(r"[ ]+$", "", string, flags=re.MULTILINE)

    formatted_lines = []

    for line in requirements_contents.splitlines():
        # Comments in the original file
        if comment_re.match(line):
            formatted_lines.append(line)
            continue

        if not multi_dep_re.match(line):
            # Requirements with only one entry in "via" are kept in the same line:
            # package==XX # via other_package
            #   becomes
            # package==XX
            #   # via other_package
            formatted = line.replace("# via", "\n    # via")
            formatted_lines.append(_remove_trailing(formatted))
            continue

        # For multiple entries in `# via` gets it's own line
        # package==XX # via other_package, and_another
        #   becomes
        # package==XX
        #   # via
        #   #   other_package
        #   #   and_another
        formatted = line.replace("# via", "\n    # via \n    #  ")
        formatted = formatted.replace(", ", "\n    #   ")
        formatted_lines.append(_remove_trailing(formatted))

    return "\n".join(formatted_lines) + "\n"  # Include new line at EOF


def reformat_requirements_txt(requirements_path):  # pragma: no cover
    """Reformat requirements.txt formatted by pip-tools.

    Formats files generated by pip-tools<5.0.5 to the format used by newer versions.

    This is required as dependabot uses the newer version
    but our local environments can't upgrade
    due to venv-update being tied to older version of pip.

    Every dependency update involves a full file
    rewrite which is impossible to review without this script.

    tox 4.0 could potentially deprecate the need for venv-update

    Details about the issue in tox:
        https://github.com/tox-dev/tox/issues/149

    and progress on the 4.0 release:
        https://tox.readthedocs.io/en/rewrite/changelog.html
    """
    with open(requirements_path, "r") as file:
        reformatted_requirements = _reformat_requirements(file.read())

    with open(requirements_path, "w") as file:
        file.write(reformatted_requirements)


def existing_in_files(in_files):
    """Get a list of *.in files.

    Filter and sort them based on a default ordering and their presence in disk
    """
    in_files = in_files or DEFAULT_REQUIREMENTS_ORDER
    # Only try to process files that actually exists
    return [p for p in in_files if Path(p).exists()]


def compile_in_files(in_files, reformat=None):
    """Entry point for the h-dev requirements command.

    Sync requirements.in files generating the corresponding .txt files
    """
    reformat = True if reformat is None else reformat
    in_files = DEFAULT_REQUIREMENTS_ORDER if in_files is None else in_files

    txt_files = [in_file.replace(".in", ".txt") for in_file in in_files]

    # Get around the year zero problem of not being able to create requirements
    # files because there are no requirements files for the tox environments
    for txt_file in txt_files:
        Path(txt_file).touch()

    tox_environments = list_tox_environments()
    for in_file in in_files:
        in_filename = os.path.basename(in_file)
        filename, _ = os.path.splitext(in_filename)

        tox_env = filename
        if filename == "requirements" or tox_env not in tox_environments:
            # Assume that requirements.txt is the base for the "dev" environment
            # also use it when it doesn't match any existing tox envs.
            tox_env = "dev"

        run_tox(
            tox_env,
            f"pip-compile {in_file}",
            extra_dependencies_path=PIP_TOOLS_REQUIREMENTS_PATH,
        )

    if reformat:
        for txt_file in txt_files:
            reformat_requirements_txt(txt_file)

    return in_files


def upgrade_package(in_files, package, env=None):
    """Upgrade one package with pip-compile."""
    tox_environments = list_tox_environments()

    if env and env not in tox_environments:
        print(f"Environment {env} doesn't exist")
        return None

    tox_env = env
    if not env:
        # If no env was provided we modify the main "requirements.txt"
        tox_env = "dev"
        env = "requirements"

    # Find the .in file that matches the environment name
    target_file = [f for f in in_files if f == f"{env}.in" or f.endswith(f"/{env}.in")]
    if not target_file:
        print(f"Can't find a *.in file that matches environment {env}")
        return None

    target_file = target_file[0]

    return run_tox(
        tox_env,
        f'pip-compile --upgrade-package "{package}" {target_file}',
        extra_dependencies_path=PIP_TOOLS_REQUIREMENTS_PATH,
    )
